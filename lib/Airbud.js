// Generated by CoffeeScript 2.5.1
(function() {
  var Airbud, fs, request, retry;

  request = require("request");

  fs = require("fs");

  retry = require("retry");

  Airbud = (function() {
    class Airbud {
      static getDefaults() {
        return Airbud._defaults;
      }

      static setDefaults(options) {
        var key, results, val;
        results = [];
        for (key in options) {
          val = options[key];
          results.push(Airbud._defaults[key] = val);
        }
        return results;
      }

      static json(options, cb) {
        var airbud;
        airbud = new Airbud(options, {
          parseJson: true
        });
        return Airbud.retrieve(airbud, cb);
      }

      static retrieve(options, cb) {
        var airbud, err;
        if (options instanceof Airbud) {
          airbud = options;
        } else {
          airbud = new Airbud(options);
        }
        try {
          return airbud.fetch(cb);
        } catch (error) {
          err = error;
          err.message = `Got an error while retrieving ${airbud.url}. ${err}`;
          return cb(err);
        }
      }

      constructor(...optionSets) {
        var i, key, len, options, val;
        optionSets.unshift(Airbud.getDefaults());
        for (i = 0, len = optionSets.length; i < len; i++) {
          options = optionSets[i];
          if (typeof options === "string") {
            options = {
              url: options
            };
          }
          for (key in options) {
            val = options[key];
            this[key] = val;
          }
        }
        // Normalize expectedStatus as we allow these input formats:
        //  - RegExp
        //  - 200
        //  - "20x"
        //  - [ "20x", "40x" ]
        //  - "xxx"
        if ((this.expectedStatus != null) && !(this.expectedStatus instanceof RegExp)) {
          if (!(this.expectedStatus instanceof Array)) {
            this.expectedStatus = [this.expectedStatus];
          }
          this.expectedStatus = this.expectedStatus.join("|").replace(/x/g, "\\d");
          this.expectedStatus = new RegExp(`^${this.expectedStatus}$`);
        }
      }

      fetch(mainCb) {
        var calledCallbacks, cb, cbOperationTimeout, operation, operationDurations, operationStart, timeoutErr, totalStart;
        operation = retry.operation({
          retries: this.retries,
          factor: this.factor,
          minTimeout: this.minInterval,
          maxTimeout: this.maxInterval,
          randomize: this.randomize
        });
        // Setup timeouts for single operation
        cbOperationTimeout = null;
        timeoutErr = null;
        operationStart = null;
        calledCallbacks = {};
        cb = (err, data, res) => {
          var meta, returnErr, totalDuration;
          if (calledCallbacks[operationStart]) {
            return;
          }
          calledCallbacks[operationStart] = true;
          operationDurations += +new Date() - operationStart;
          if (operation.retry(err)) {
            return;
          }
          totalDuration = +new Date() - totalStart;
          meta = {
            statusCode: res != null ? res.statusCode : void 0,
            errors: operation.errors(),
            attempts: operation.attempts(),
            totalDuration: totalDuration,
            operationDuration: Math.floor(operationDurations / operation.attempts())
          };
          returnErr = err ? operation.mainError() : null;
          if (this.fetchResponseObj) {
            meta.responseObj = res;
          }
          return mainCb(returnErr, data, meta);
        };
        if (this.operationTimeout != null) {
          cbOperationTimeout = {
            timeout: this.operationTimeout,
            cb: () => {
              var msg;
              msg = `Operation timeout of ${this.operationTimeout}ms reached.`;
              timeoutErr = new Error(msg);
              return cb(timeoutErr);
            }
          };
        }
        totalStart = +new Date();
        operationDurations = 0;
        return operation.attempt((currentAttempt) => {
          operationStart = +new Date();
          calledCallbacks[operationStart] = false;
          return this._execute(cb);
        }, cbOperationTimeout);
      }

      _execute(cb) {
        var err, path, reqOpts;
        if (!this.url) {
          err = new Error("You did not specify a url to fetch");
          return cb(err);
        }
        if (this.url.indexOf("file://") === 0) {
          // Url can also be local json to inject test fixtures
          path = this.url.substr(7, this.url.length).split("?")[0];
          fs.readFile(path, "utf8", (err, buf) => {
            var returnErr;
            if (err) {
              returnErr = new Error(`Cannot open '${path}'. ${err.message}`);
              return cb(returnErr);
            }
            return this._handleData(buf, {}, cb);
          });
          return;
        }
        reqOpts = {
          url: this.url
        };
        if (this.headers != null) {
          reqOpts.headers = this.headers;
        }
        if (this.auth != null) {
          reqOpts.auth = this.auth;
        }
        return request.get(reqOpts, (err, res, buf) => {
          var msg;
          if (err) {
            return cb(err, buf, res);
          }
          if (this.expectedStatus != null) {
            if (!this.expectedStatus.test(res.statusCode + "")) {
              msg = `HTTP Status ${res.statusCode} received when fetching '${this.url}'. `;
              msg += `Expected: ${this.expectedStatus}. ${(buf + "").substr(0, 30)}..`;
              err = new Error(msg);
              return cb(err, buf, res);
            }
          }
          return this._handleData(buf, res, cb);
        });
      }

      _handleData(buf, res, cb) {
        var data, err, msg;
        data = buf;
        if (!this.parseJson) {
          return cb(null, data, res);
        }
        try {
          data = JSON.parse(data);
        } catch (error) {
          err = error;
          err.message = `Got an error while parsing json for ${this.url}. ${err}`;
          return cb(err, data, res);
        }
        if ((this.expectedKey != null) && (data[this.expectedKey] == null)) {
          msg = `Invalid body received when fetching '${this.url}'. \n`;
          msg += `No key: ${this.expectedKey}. ${buf}`;
          err = new Error(msg);
          return cb(err, data, res);
        }
        return cb(null, data, res);
      }

    };

    Airbud._defaults = {
      // Timeout of a single operation
      operationTimeout: 30000,
      // Retry 5 times over 10 minutes
      // http://www.wolframalpha.com/input/?i=Sum%5Bx%5Ek+*+5%2C+%7Bk%2C+0%2C+4%7D%5D+%3D+10+*+60+%26%26+x+%3E+0
      // The maximum amount of times to retry the operation
      retries: 4,
      // The exponential factor to use
      factor: 2.99294,
      // The number of milliseconds before starting the first retry
      minInterval: 5 * 1000,
      // The maximum number of milliseconds between two retries
      maxInterval: 2e308,
      // Randomizes the intervals by multiplying with a factor between 1 to 2
      randomize: true,
      // Automatically parse json
      parseJson: null,
      // Includes the full response object in the meta property of the main callback
      fetchResponseObj: false,
      // A key to find in the rootlevel of the parsed json.
      // If not found, Airbud will error out
      expectedKey: null,
      // An array of allowed HTTP Status codes. If specified,
      // Airbud will error out if the actual status doesn't match.
      // 30x redirect codes are followed automatically.
      expectedStatus: "20x",
      // Custom headers to submit in the request
      headers: [],
      // Custom auth to submit in the request
      auth: null
    };

    return Airbud;

  }).call(this);

  module.exports = Airbud;

}).call(this);
